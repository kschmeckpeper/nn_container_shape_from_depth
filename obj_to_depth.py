import vtk
from pycaster import pycaster
import numpy as np
from PIL import Image
import cv2
from math import cos, sin
import random
import os


width = 640
height = 640
fx = 500
fy = 500
camera_distance = 4
add_ground_plane = True


test_fraction = 0.1
output_path = 'data_with_table'

def pixel_to_world(x, y, start_point, angle):
    dist = 1000

    x -= width / 2
    y -= height / 2

    pos = [dist * x / fx, -dist * y / fy, dist]

    rotated_pos = [pos[0], 
                   cos(angle) * pos[1] + sin(angle) * pos[2], 
                   cos(angle) * pos[2] - sin(angle) * pos[1]]
    return rotated_pos



with open(os.path.join(output_path, "train.txt"), 'a') as train_file:
    with open(os.path.join(output_path, "test.txt"), 'a') as test_file:
        #for i in range(53, 285):
        for i in range(0, 285):
            caster = pycaster.rayCaster.fromSTL("/home/karl/glass/nn_container_shape_from_depth/stl_files/autogenerated_" + str(i) + ".stl", scale=1)

            for j in range(1, 5):
                angle = - j / 4.0  * np.pi * 2 / 8

                unrotated_pos = np.array([random.random() * camera_distance / 20,
                                          random.random() * camera_distance / 20,
                                          -camera_distance])

                pos_angle = angle #+ np.pi / 8 * random.random() - np.pi / 16

                start_point = np.array([unrotated_pos[0],
                                        cos(pos_angle) * unrotated_pos[1] + sin(pos_angle) * unrotated_pos[2],
                                        cos(pos_angle) * unrotated_pos[2] - sin(pos_angle) * unrotated_pos[1]])
                #start_point = unrotated_pos
                #print angle, start_point
                depths = np.ones((height, width)) * 1000

                for x in range(0, width, 1):
                    for y in range(0, height, 1):
                        target = pixel_to_world(x, y, start_point, angle)
                        # print target
                        intersections = caster.castRay(start_point, target)

                        distances = [np.linalg.norm(np.array(intersect) - start_point) for intersect in intersections]

                        if add_ground_plane:
                            if start_point[1] > 0 and target[1] < 0:
                                direction = start_point - target
                                distance = np.linalg.norm(start_point[1] / direction[1] * direction)
                                distances.append(distance)

                        # Scales the pixels
                        distances = [d * 50 for d in distances]

                        # Defaults to white if no intersect
                        distances.append(255)
                        depths[y, x] = min(distances)


                img = Image.fromarray(depths)
                
                file_name = 'autogenerated_' + str(i) + '_' +str(j) + '.png'
                cv2.imwrite(os.path.join(output_path, 'depth_images', file_name), depths)
                
                print "Saved", i, j

                if random.random() < test_fraction:
                    test_file.write(file_name + '\n')
                else:
                    train_file.write(file_name + '\n')


